namespace OtherMediator.SourceGenerator;

using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

[Generator]
public class MediatorIncrementalGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "MediatorAttributes.g.cs",
            GenerateAttributeSource()));

        var handlerDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsPotentialHandler(s),
                transform: static (ctx, _) => GetHandlerInfo(ctx))
            .Where(static m => m is not null);

        var compilation = context.CompilationProvider.Combine(handlerDeclarations.Collect());

        context.RegisterSourceOutput(compilation,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsPotentialHandler(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDecl &&
            classDecl.BaseList?.Types.Count > 0;
    }

    private static HandlerInfo? GetHandlerInfo(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;

        if (symbol is null)
            return null;

        var allInterfaces = GetAllInterfaces(symbol);

        foreach (var iface in allInterfaces)
        {
            if (iface.Name == "IRequestHandler" &&
                iface.TypeArguments.Length == 2)
            {
                var requestType = iface.TypeArguments[0];
                var responseType = iface.TypeArguments[1];

                return new HandlerInfo(
                    HandlerType.Request,
                    symbol.ToDisplayString(),
                    requestType.ToDisplayString(),
                    responseType.ToDisplayString(),
                    symbol.ContainingNamespace.ToDisplayString()
                );
            }
        }

        foreach (var iface in allInterfaces)
        {
            if (iface.Name == "INotificationHandler" &&
                iface.TypeArguments.Length == 1)
            {
                var notificationType = iface.TypeArguments[0];

                return new HandlerInfo(
                    HandlerType.Notification,
                    symbol.ToDisplayString(),
                    notificationType.ToDisplayString(),
                    "void",
                    symbol.ContainingNamespace.ToDisplayString()
                );
            }
        }

        return null;
    }

    private static IEnumerable<INamedTypeSymbol> GetAllInterfaces(INamedTypeSymbol symbol)
    {
        var interfaces = new List<INamedTypeSymbol>();
        var current = symbol;

        while (current != null)
        {
            interfaces.AddRange(current.Interfaces);
            current = current.BaseType;
        }

        return interfaces.Distinct(SymbolEqualityComparer.Default).Cast<INamedTypeSymbol>();
    }

    private static void Execute(
        Compilation compilation,
        IEnumerable<HandlerInfo> handlers,
        SourceProductionContext context)
    {
        if (!handlers.Any())
            return;

        var handlersList = handlers.ToList();
        var requestHandlers = handlersList.Where(h => h.Type == HandlerType.Request).ToList();

        var notificationHandlers = handlersList
            .Where(h => h.Type == HandlerType.Notification)
            .GroupBy(h => h.RequestType)
            .Select(g => g.First())
            .ToList();

        var source = GenerateMediatorSource(requestHandlers, notificationHandlers);
        context.AddSource("Mediator.g.cs", source);

        var diSource = GenerateDependencyInjectionSource(handlersList);
        context.AddSource("MediatorServiceCollectionExtensions.g.cs", diSource);
    }

    private static string GenerateAttributeSource()
    {
        return @"
namespace OtherMediator;

[System.AttributeUsage(System.AttributeTargets.Assembly)]
internal class GenerateMediatorAttribute : System.Attribute
{
}";
    }

    private static string GenerateMediatorSource(
        List<HandlerInfo> requestHandlers,
        List<HandlerInfo> notificationHandlers)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("namespace OtherMediator.Generated;");
        sb.AppendLine();
        sb.AppendLine("internal sealed class Mediator : global::OtherMediator.Contracts.IMediator");
        sb.AppendLine("{");
        sb.AppendLine("    private readonly global::System.IServiceProvider _serviceProvider;");
        sb.AppendLine();
        sb.AppendLine("    public Mediator(global::System.IServiceProvider serviceProvider)");
        sb.AppendLine("    {");
        sb.AppendLine("        _serviceProvider = serviceProvider;");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    public global::System.Threading.Tasks.Task<TResponse> Send<TRequest, TResponse>(TRequest request, global::System.Threading.CancellationToken cancellationToken = default)");
        sb.AppendLine("        where TRequest : global::OtherMediator.Contracts.IRequest<TResponse>");
        sb.AppendLine("    {");

        if (requestHandlers.Any())
        {
            sb.AppendLine("        return request switch");
            sb.AppendLine("        {");

            foreach (var handler in requestHandlers)
            {
                var methodName = GetMethodName(handler.RequestType);
                sb.AppendLine($"            {handler.RequestType} typedRequest => HandleAsync{methodName}<TResponse>(typedRequest, cancellationToken),");
            }

            sb.AppendLine("            _ => throw new global::System.InvalidOperationException($\"No handler registered for {typeof(TRequest).Name}\")");
            sb.AppendLine("        };");
        }
        else
        {
            sb.AppendLine("        throw new global::System.InvalidOperationException(\"No request handlers registered\");");
        }

        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    public global::System.Threading.Tasks.Task<global::OtherMediator.Contracts.Unit> Send<TRequest>(TRequest request, global::System.Threading.CancellationToken cancellationToken = default)");
        sb.AppendLine("        where TRequest : global::OtherMediator.Contracts.IRequest<global::OtherMediator.Contracts.Unit>");
        sb.AppendLine("    {");
        sb.AppendLine("        return Send<TRequest, global::OtherMediator.Contracts.Unit>(request, cancellationToken);");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    public async global::System.Threading.Tasks.Task Publish<TNotification>(TNotification notification, global::System.Threading.CancellationToken cancellationToken = default)");
        sb.AppendLine("        where TNotification : global::OtherMediator.Contracts.INotification");
        sb.AppendLine("    {");

        if (notificationHandlers.Any())
        {
            sb.AppendLine("        switch (notification)");
            sb.AppendLine("        {");

            foreach (var handler in notificationHandlers)
            {
                var methodName = GetMethodName(handler.RequestType);
                sb.AppendLine($"            case {handler.RequestType} typedNotification:");
                sb.AppendLine($"                await global::System.Threading.Tasks.Task.WhenAll(PublishAsync{methodName}(typedNotification, cancellationToken));");
                sb.AppendLine("                break;");
            }

            sb.AppendLine("            default:");
            sb.AppendLine("                break;");
            sb.AppendLine("        }");
        }
        else
        {
            sb.AppendLine("        // No notification handlers registered");
            sb.AppendLine("        await global::System.Threading.Tasks.Task.CompletedTask;");
        }

        sb.AppendLine("    }");
        sb.AppendLine();

        foreach (var handler in requestHandlers)
        {
            var methodName = GetMethodName(handler.RequestType);

            sb.AppendLine($"    private async global::System.Threading.Tasks.Task<TResponse> HandleAsync{methodName}<TResponse>(");
            sb.AppendLine($"        {handler.RequestType} request,");
            sb.AppendLine($"        global::System.Threading.CancellationToken cancellationToken)");
            sb.AppendLine("    {");
            sb.AppendLine($"        var handler = ({handler.HandlerFullType})_serviceProvider.GetService(typeof({handler.HandlerFullType}))");
            sb.AppendLine($"            ?? throw new global::System.InvalidOperationException(\"Handler {handler.HandlerFullType} not registered\");");
            sb.AppendLine($"        var result = await handler.Handle(request, cancellationToken);");

            sb.AppendLine($"        if (result is TResponse typedResult)");
            sb.AppendLine("        {");
            sb.AppendLine("            return typedResult;");
            sb.AppendLine("        }");
            sb.AppendLine("        else if (result == null && default(TResponse) == null)");
            sb.AppendLine("        {");
            sb.AppendLine("            return default!;");
            sb.AppendLine("        }");
            sb.AppendLine("        else");
            sb.AppendLine("        {");
            sb.AppendLine($"            return (TResponse)(object)result!;");
            sb.AppendLine("        }");

            sb.AppendLine("    }");
            sb.AppendLine();
        }

        foreach (var handler in notificationHandlers)
        {
            var methodName = GetMethodName(handler.RequestType);
            var interfaceType = $"global::OtherMediator.Contracts.INotificationHandler<{handler.RequestType}>";

            sb.AppendLine($"    private global::System.Threading.Tasks.Task[] PublishAsync{methodName}(");
            sb.AppendLine($"        {handler.RequestType} notification,");
            sb.AppendLine($"        global::System.Threading.CancellationToken cancellationToken)");
            sb.AppendLine("    {");
            sb.AppendLine($"        var handlers = _serviceProvider.GetService(typeof(global::System.Collections.Generic.IEnumerable<{interfaceType}>)) as global::System.Collections.Generic.IEnumerable<{interfaceType}>;");
            sb.AppendLine("        if (handlers == null) return global::System.Array.Empty<global::System.Threading.Tasks.Task>();");
            sb.AppendLine();
            sb.AppendLine("        return global::System.Linq.Enumerable.ToArray(global::System.Linq.Enumerable.Select(handlers, h => h.Handle(notification, cancellationToken)));");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string GenerateDependencyInjectionSource(IEnumerable<HandlerInfo> handlers)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("#pragma warning disable");
        sb.AppendLine();
        sb.AppendLine("namespace OtherMediator;");
        sb.AppendLine();
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();
        sb.AppendLine("public static class MediatorServiceCollectionExtensions");
        sb.AppendLine("{");
        sb.AppendLine("    public static global::Microsoft.Extensions.DependencyInjection.IServiceCollection AddMediator(this global::Microsoft.Extensions.DependencyInjection.IServiceCollection services)");
        sb.AppendLine("    {");
        sb.AppendLine("        services.AddSingleton<global::OtherMediator.Contracts.IMediator, global::OtherMediator.Generated.Mediator>();");
        sb.AppendLine("        services.AddSingleton<global::OtherMediator.Contracts.ISender>(sp => sp.GetRequiredService<global::OtherMediator.Contracts.IMediator>());");
        sb.AppendLine("        services.AddSingleton<global::OtherMediator.Contracts.IPublisher>(sp => sp.GetRequiredService<global::OtherMediator.Contracts.IMediator>());");
        sb.AppendLine();

        var requestHandlers = handlers.Where(h => h.Type == HandlerType.Request);
        var notificationHandlers = handlers.Where(h => h.Type == HandlerType.Notification);

        foreach (var handler in requestHandlers)
        {
            sb.AppendLine($"        services.AddTransient(typeof({handler.HandlerFullType}));");
        }

        foreach (var handler in notificationHandlers)
        {
            var interfaceType = $"global::OtherMediator.Contracts.INotificationHandler<{handler.RequestType}>";
            sb.AppendLine($"        services.AddTransient(typeof({interfaceType}), typeof({handler.HandlerFullType}));");
        }

        sb.AppendLine();
        sb.AppendLine("        return services;");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine("#pragma warning restore");

        return sb.ToString();
    }

    private static string GetMethodName(string typeName)
    {
        var lastDot = typeName.LastIndexOf('.');
        return lastDot >= 0 ? typeName.Substring(lastDot + 1) : typeName;
    }

    private static string GetVariableName(string typeName)
    {
        var methodName = GetMethodName(typeName);
        return char.ToLowerInvariant(methodName[0]) + methodName.Substring(1);
    }

    private enum HandlerType
    {
        Request,
        Notification
    }

    private class HandlerInfo
    {
        public HandlerType Type { get; }
        public string HandlerFullType { get; }
        public string RequestType { get; }
        public string ResponseType { get; }
        public string Namespace { get; }

        public HandlerInfo(
            HandlerType type,
            string handlerFullType,
            string requestType,
            string responseType,
            string @namespace)
        {
            Type = type;
            HandlerFullType = handlerFullType;
            RequestType = requestType;
            ResponseType = responseType;
            Namespace = @namespace;
        }
    }
}
